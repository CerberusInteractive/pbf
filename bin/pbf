#!/usr/bin/env node

'use strict';

var resolve = require('resolve-protobuf-schema');

if (process.argv.length < 3) {
    console.error('Usage: pbf [file.proto] [--browser] [--no-read] [--no-write]');
    return;
}

var proto = resolve.sync(process.argv[2]);
var exportsVar = process.argv.indexOf('--browser') >= 0 ? 'window' : 'exports';
var noRead = process.argv.indexOf('--no-read') >= 0;
var noWrite = process.argv.indexOf('--no-write') >= 0;

console.log('\'use strict\';');

writeContext(buildContext(proto, null));

function writeContext(ctx) {
    if (ctx._proto.fields) writeMessage(ctx);
    if (ctx._proto.values) writeEnum(ctx);

    for (var i = 0; i < ctx._children.length; i++) {
        writeContext(ctx._children[i]);
    }
}

function writeMessage(ctx) {
    var name = ctx._name;
    var fields = ctx._proto.fields;

    console.log('\n// %s ========================================\n', name);

    if (!noRead) {
        console.log('%s {};\n', compileExport(ctx));

        console.log('%s.read = function (pbf, end) {', name);
        console.log('    return pbf.readFields(%s._readField, %s, end);', name, compileDest(ctx));
        console.log('};');
        console.log('%s._readField = function (tag, obj, pbf) {', ctx._name);
        for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            var readCode = compileFieldRead(ctx, field);
            console.log('    ' + (i ? 'else if' : 'if') + ' (tag === %d) obj.%s' +
                (field.repeated && !field.options.packed ? '.push(%s);' : ' = %s;'),
                field.tag, field.name, readCode);
        }
        console.log('};');
    }

    if (!noWrite) {
        console.log('%s.write = function (obj, pbf) {', name);
        var numRepeated = 0;
        for (i = 0; i < fields.length; i++) {
            field = fields[i];
            var writeCode = field.repeated && !field.options.packed ?
                compileRepeatedWrite(ctx, field, numRepeated++) :
                compileFieldWrite(ctx, field, field.name);
            console.log('    if (obj.%s !== undefined) %s;', field.name, writeCode);
        }
        console.log('};');
    }
}

function writeEnum(ctx) {
    console.log('\n%s %s;', compileExport(ctx), JSON.stringify(ctx._proto.values, null, 4));
}

function compileExport(ctx) {
    return (ctx._root ? 'var ' + ctx._name + ' = ' + exportsVar + '.' : '') + ctx._name + ' =';
}

function compileDest(ctx) {
    var props = [];
    for (var i = 0; i < ctx._proto.fields.length; i++) {
        var field = ctx._proto.fields[i];

        if (field.repeated && !field.options.packed)
            props.push(field.name + ': []');

        var type = ctx[field.type];

        if (type && type._proto.values && field.options.default !== undefined)
            props.push(field.name + ': ' + JSON.stringify(field.options.default));
    }
    return '{' + props.join(', ') + '}';
}

function compileFieldRead(ctx, field) {
    var type = ctx[field.type];
    if (type) {
        if (type._proto.fields) return type._name + '.read(pbf, pbf.readVarint() + pbf.pos)';
        if (type._proto.values) return 'pbf.readVarint()';
        throw new Error('Unexpected type: ' + type._name);
    }

    var prefix = 'pbf.read';
    if (field.options.packed) prefix += 'Packed';

    switch (field.type) {
    case 'string':   return prefix + 'String()';
    case 'float':    return prefix + 'Float()';
    case 'double':   return prefix + 'Double()';
    case 'bool':     return prefix + 'Boolean()';
    case 'enum':
    case 'uint32':
    case 'uint64':
    case 'int32':
    case 'int64':    return prefix + 'Varint()';
    case 'sint32':
    case 'sint64':   return prefix + 'SVarint()';
    case 'fixed32':  return prefix + 'Fixed32()';
    case 'fixed64':  return prefix + 'Fixed64()';
    case 'sfixed32': return prefix + 'SFixed32()';
    case 'sfixed64': return prefix + 'SFixed64()';
    case 'bytes':    return prefix + 'Bytes()';
    default:         throw new Error('Unexpected type: ' + field.type);
    }
}

function compileFieldWrite(ctx, field, name) {
    var prefix = 'pbf.write';
    if (field.options.packed) prefix += 'Packed';

    var postfix = (field.options.packed ? '' : 'Field') + '(' + field.tag + ', obj.' + name + ')';

    var type = ctx[field.type];
    if (type) {
        if (type._proto.fields) return prefix + 'Message(' + field.tag + ', ' + type._name + '.write, obj.' + name + ')';
        if (type._proto.values) return prefix + 'Varint' + postfix;
        throw new Error('Unexpected type: ' + type._name);
    }

    switch (field.type) {
    case 'string':   return prefix + 'String' + postfix;
    case 'float':    return prefix + 'Float' + postfix;
    case 'double':   return prefix + 'Double' + postfix;
    case 'bool':     return prefix + 'Boolean' + postfix;
    case 'enum':
    case 'uint32':
    case 'uint64':
    case 'int32':
    case 'int64':    return prefix + 'Varint' + postfix;
    case 'sint32':
    case 'sint64':   return prefix + 'SVarint' + postfix;
    case 'fixed32':  return prefix + 'Fixed32' + postfix;
    case 'fixed64':  return prefix + 'Fixed64' + postfix;
    case 'sfixed32': return prefix + 'SFixed32' + postfix;
    case 'sfixed64': return prefix + 'SFixed64' + postfix;
    case 'bytes':    return prefix + 'Bytes' + postfix;
    default:         throw new Error('Unexpected type: ' + field.type);
    }
}

function compileRepeatedWrite(ctx, field, numRepeated) {
    return 'for (' + (numRepeated ? '' : 'var ') +
        'i = 0; i < obj.' + field.name + '.length; i++) ' +
        compileFieldWrite(ctx, field, field.name + '[i]');
}

function buildContext(proto, parent) {
    var obj = Object.create(parent);
    obj._proto = proto;
    obj._children = [];

    if (parent) {
        parent[proto.name] = obj;

        if (parent._name) {
            obj._root = false;
            obj._name = parent._name + '.' + proto.name;
        } else {
            obj._root = true;
            obj._name = proto.name;
        }
    }

    for (var i = 0; proto.enums && i < proto.enums.length; i++) {
        obj._children.push(buildContext(proto.enums[i], obj));
    }

    for (i = 0; proto.messages && i < proto.messages.length; i++) {
        obj._children.push(buildContext(proto.messages[i], obj));
    }

    return obj;
}
